using Logging.Abstractions;
using Logging.Extensions;
using Logging.Helpers;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using System;
using System.IO;
using System.Text;
using System.Text.Json;

namespace Logging.Services
{
    /// <summary>
    /// Implementación del servicio de logging.
    /// Se encarga de escribir logs en archivos únicos por petición utilizando la ruta:
    /// [BaseLogDirectory]\[NombreApi]\, donde BaseLogDirectory se configura desde el appsettings.json.
    /// Si ocurre un error interno, se registra en "InternalErrorLog.txt" sin afectar la API.
    /// </summary>
    public class LoggingService : ILoggingService
    {
        // Ruta final de logs, combinando la ruta base configurada y el nombre de la API.
        private readonly string _logDirectory;
        // Acceso al contexto HTTP actual.
        private readonly IHttpContextAccessor _httpContextAccessor;

        /// <summary>
        /// Versión de la librería para control de versionamiento.
        /// </summary>
        public const string LibraryVersion = "1.0.0";

        // Reutilizamos una única instancia estática de JsonSerializerOptions para evitar crear nuevas instancias.
        private static readonly JsonSerializerOptions SerializerOptions = new() { WriteIndented = true };

        /// <summary>
        /// Constructor que inicializa el servicio de logging.
        /// Se inyectan IHttpContextAccessor, IHostEnvironment y las opciones de configuración (LoggingOptions) para obtener la ruta base.
        /// La ruta final se forma combinando BaseLogDirectory con el ApplicationName.
        /// </summary>
        /// <param name="httpContextAccessor">Acceso al contexto HTTP actual.</param>
        /// <param name="hostEnvironment">Información del entorno de la aplicación.</param>
        /// <param name="options">Opciones de configuración para logging (definidas en appsettings.json).</param>
        public LoggingService(IHttpContextAccessor httpContextAccessor, IHostEnvironment hostEnvironment, IOptions<Logging.Configuration.LoggingOptions> options)
        {
            _httpContextAccessor = httpContextAccessor;
            string baseLogDir = options.Value.BaseLogDirectory;
            string apiName = !string.IsNullOrWhiteSpace(hostEnvironment.ApplicationName) ? hostEnvironment.ApplicationName : "Desconocido";
            _logDirectory = Path.Combine(baseLogDir, apiName);
            try
            {
                if (!Directory.Exists(_logDirectory))
                    Directory.CreateDirectory(_logDirectory);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Obtiene el archivo de log actual asociado a la petición.
        /// Si no existe un archivo asignado para la petición, retorna un archivo global para logs manuales.
        /// </summary>
        /// <returns>Ruta del archivo de log actual.</returns>
        private string GetCurrentLogFile()
        {
            try
            {
                var context = _httpContextAccessor.HttpContext;
                if (context != null && context.Items.ContainsKey("LogFileName"))
                {
                    return context.Items["LogFileName"] as string;
                }
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
            return Path.Combine(_logDirectory, "GlobalManualLogs.txt");
        }

        /// <summary>
        /// Registra un error interno en el archivo "InternalErrorLog.txt".
        /// Esto asegura que cualquier fallo interno se capture sin afectar la ejecución de la API.
        /// </summary>
        /// <param name="ex">La excepción a registrar.</param>
        private void LogInternalError(Exception ex)
        {
            try
            {
                var errorLogPath = Path.Combine(_logDirectory, "InternalErrorLog.txt");
                var errorMessage = $"[{DateTime.Now}] Error en LoggingService: {ex}{Environment.NewLine}";
                File.AppendAllText(errorLogPath, errorMessage);
            }
            catch
            {
                // Si falla la escritura en el log interno, se ignora para evitar ciclos de error.
            }
        }

        /// <summary>
        /// Escribe el contenido del log en un archivo único para la petición actual.
        /// </summary>
        /// <param name="context">El contexto HTTP de la petición.</param>
        /// <param name="logContent">El contenido del log a escribir.</param>
        public void WriteLog(HttpContext context, string logContent)
        {
            try
            {
                var fileName = Path.Combine(_logDirectory, $"Log_{context.TraceIdentifier}.txt");
                File.AppendAllText(fileName, logContent.Indent(LogScope.CurrentLevel) + Environment.NewLine + Environment.NewLine);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Agrega un log simple (mensaje de texto) al archivo de log actual.
        /// </summary>
        /// <param name="logMessage">El mensaje a registrar.</param>
        public void AddSingleLog(string logMessage)
        {
            try
            {
                var formatted = LogFormatter.FormatSingleLog(logMessage).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Agrega un log de objeto serializado a JSON al archivo de log actual.
        /// </summary>
        /// <param name="objectName">El nombre identificador del objeto.</param>
        /// <param name="logObject">El objeto a registrar.</param>
        public void AddObjLog(string objectName, object logObject)
        {
            try
            {
                // Se utiliza la instancia estática SerializerOptions para serializar el objeto.
                string logContent = JsonSerializer.Serialize(logObject, SerializerOptions);
                var formatted = LogFormatter.FormatObjectLog(objectName, logContent).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Agrega un log con la información de la respuesta HTTP.
        /// </summary>
        /// <param name="logMessage">El mensaje o datos de la respuesta a registrar.</param>
        public void AddResponseLog(string logMessage)
        {
            try
            {
                var formatted = LogFormatter.FormatResponseInfo(logMessage).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Agrega un log con información del entorno, utilizando datos del HttpContext y del sistema.
        /// Si algún dato no se puede obtener, se utiliza "Desconocido".
        /// </summary>
        /// <param name="logMessage">Mensaje adicional para el bloque de entorno.</param>
        public void AddEnvironmentLog(string logMessage)
        {
            try
            {
                var sb = new StringBuilder();
                sb.AppendLine(LogFormatter.FormatEnvironmentInfoStart(
                    application: GetValueOrDefault(() => _httpContextAccessor.HttpContext.RequestServices.GetService(typeof(IHostEnvironment)) as IHostEnvironment)?.ApplicationName ?? "Desconocido",
                    env: GetValueOrDefault(() => _httpContextAccessor.HttpContext.RequestServices.GetService(typeof(IHostEnvironment)) as IHostEnvironment)?.EnvironmentName ?? "Desconocido",
                    contentRoot: GetValueOrDefault(() => _httpContextAccessor.HttpContext.RequestServices.GetService(typeof(IHostEnvironment)) as IHostEnvironment)?.ContentRootPath ?? "Desconocido",
                    executionId: _httpContextAccessor.HttpContext?.TraceIdentifier ?? "Desconocido",
                    clientIp: _httpContextAccessor.HttpContext?.Connection.RemoteIpAddress?.ToString() ?? "Desconocido",
                    userAgent: _httpContextAccessor.HttpContext?.Request.Headers["User-Agent"].ToString() ?? "Desconocido",
                    machineName: Environment.MachineName,
                    os: Environment.OSVersion.ToString(),
                    host: _httpContextAccessor.HttpContext?.Request.Host.ToString() ?? "Desconocido",
                    distribution: "Desconocido"
                ));
                sb.AppendLine(logMessage);
                sb.AppendLine(LogFormatter.FormatEnvironmentInfoEnd());
                File.AppendAllText(GetCurrentLogFile(), sb.ToString().Indent(LogScope.CurrentLevel));
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Agrega un log con la información de una excepción.
        /// Se registra el mensaje completo de la excepción o "Sin excepciones" si es nulo.
        /// </summary>
        /// <param name="ex">La excepción a registrar.</param>
        public void AddExceptionLog(Exception ex)
        {
            try
            {
                var formatted = LogFormatter.FormatExceptionDetails(ex?.ToString() ?? "Sin excepciones").Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception e)
            {
                LogInternalError(e);
            }
        }

        /// <summary>
        /// Agrega un log con los parámetros de entrada.
        /// </summary>
        /// <param name="parameters">Cadena que representa los parámetros de entrada.</param>
        public void AddInputParameters(string parameters)
        {
            try
            {
                var formatted = LogFormatter.FormatInputParameters(parameters).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Agrega un log con los parámetros de salida.
        /// </summary>
        /// <param name="parameters">Cadena que representa los parámetros de salida.</param>
        public void AddOutputParameters(string parameters)
        {
            try
            {
                var formatted = LogFormatter.FormatOutputParameters(parameters).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Función auxiliar para obtener un valor mediante un getter.
        /// Si ocurre un error, se registra la excepción y se retorna el valor por defecto.
        /// </summary>
        /// <typeparam name="T">El tipo del valor a obtener.</typeparam>
        /// <param name="getter">Función que obtiene el valor.</param>
        /// <returns>El valor obtenido o el valor por defecto si ocurre un error.</returns>
        private T GetValueOrDefault<T>(Func<T> getter)
        {
            try
            {
                return getter();
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
                return default;
            }
        }
    }
}
