Estructura del Proyecto

MyCompany.Logging/
├── MyCompany.Logging.csproj
├── MyCompany.Logging.nuspec
├── AssemblyInfo.cs
├── README.md
├── Abstractions/
│   └── ILoggingService.cs
├── Extensions/
│   └── StringExtensions.cs
├── Helpers/
│   ├── LogFormatter.cs
│   └── LogScope.cs
├── Middleware/
│   └── LoggingMiddleware.cs
├── Filters/
│   └── LoggingActionFilter.cs
└── Services/
    └── LoggingService.cs

Contenido de los Archivos
1. MyCompany.Logging.csproj

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <!-- Definir el TargetFramework -->
    <TargetFramework>net6.0</TargetFramework>
    <!-- Versión del ensamblado -->
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
    <FileVersion>1.0.0.0</FileVersion>
    <!-- Metadatos para NuGet -->
    <PackageId>MyCompany.Logging</PackageId>
    <Version>1.0.0</Version>
    <Authors>My Company</Authors>
    <Description>Librería de logging para APIs ASP.NET Core que captura información de request/response y el flujo de ejecución.</Description>
    <!-- Generar el paquete NuGet automáticamente al compilar -->
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
  </PropertyGroup>
  
  <ItemGroup>
    <!-- Dependencias con rangos de versión -->
    <PackageReference Include="Microsoft.AspNetCore.Http.Abstractions" Version="[2.2.0,3.0.0)" />
    <PackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="[2.2.0,3.0.0)" />
    <PackageReference Include="System.Text.Json" Version="[4.7.0,5.0.0)" />
  </ItemGroup>
  
  <ItemGroup>
    <Compile Include="AssemblyInfo.cs" />
    <Compile Include="Abstractions\ILoggingService.cs" />
    <Compile Include="Extensions\StringExtensions.cs" />
    <Compile Include="Helpers\LogFormatter.cs" />
    <Compile Include="Helpers\LogScope.cs" />
    <Compile Include="Middleware\LoggingMiddleware.cs" />
    <Compile Include="Filters\LoggingActionFilter.cs" />
    <Compile Include="Services\LoggingService.cs" />
  </ItemGroup>
</Project>

2. MyCompany.Logging.nuspec

<?xml version="1.0"?>
<package>
  <metadata>
    <id>MyCompany.Logging</id>
    <version>1.0.0</version>
    <authors>My Company</authors>
    <owners>My Company</owners>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <description>Librería de logging para APIs ASP.NET Core que captura información de request/response y el flujo de ejecución.</description>
    <dependencies>
      <group targetFramework=".NETCoreApp,Version=v6.0">
        <dependency id="Microsoft.AspNetCore.Http.Abstractions" version="[2.2.0,3.0.0)" />
        <dependency id="Microsoft.Extensions.Hosting.Abstractions" version="[2.2.0,3.0.0)" />
        <dependency id="System.Text.Json" version="[4.7.0,5.0.0)" />
      </group>
    </dependencies>
  </metadata>
</package>

3. AssemblyInfo.cs

using System.Reflection;

// Atributos de ensamblado para el versionamiento de la librería
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

4. README.md

# MyCompany.Logging

Esta librería de logging para APIs ASP.NET Core captura información de request/response, el flujo de ejecución y parámetros de entrada/salida.  
Incluye manejo robusto de errores internos y utiliza scopes anidados para reflejar la jerarquía del flujo del código del usuario.

## Características

- Registra logs en archivos ubicados en `C:\Logs\[NombreDeLaAPI]\`, donde el nombre de la API se obtiene dinámicamente.
- Declara dependencias con rangos de versión para evitar conflictos.
- Maneja internamente errores en el logging (registrándolos en `InternalErrorLog.txt`).
- Control de versionamiento (versión actual 1.0.0).
- Código completamente comentado para facilitar el mantenimiento.

## Uso

1. Instala el paquete NuGet o referencia la DLL.
2. En el API, registra los servicios de logging:
    ```csharp
    builder.Services.AddHttpContextAccessor();
    builder.Services.AddSingleton<ILoggingService, LoggingService>();
    builder.Services.AddControllers(options => {
        options.Filters.Add(typeof(LoggingActionFilter));
    });
    ```
3. Agrega el middleware en el pipeline:
    ```csharp
    app.UseMiddleware<Logging.Middleware.LoggingMiddleware>();
    ```
4. Configura según sea necesario.

## Versionamiento

Versión actual: 1.0.0

5. Abstractions/ILoggingService.cs

using Microsoft.AspNetCore.Http;
using System;

namespace Logging.Abstractions
{
    /// <summary>
    /// Interfaz para el servicio de logging.
    /// Define métodos para registrar logs automáticos y manuales, así como parámetros de entrada y salida.
    /// </summary>
    public interface ILoggingService
    {
        void WriteLog(HttpContext context, string logContent);
        void AddSingleLog(string logMessage);
        void AddObjLog(string objectName, object logObject);
        void AddResponseLog(string logMessage);
        void AddEnvironmentLog(string logMessage);
        void AddExceptionLog(Exception ex);
        void AddInputParameters(string parameters);
        void AddOutputParameters(string parameters);
    }
}

6. Extensions/StringExtensions.cs

using System;
using System.Linq;

namespace Logging.Extensions
{
    /// <summary>
    /// Provee métodos de extensión para trabajar con cadenas.
    /// </summary>
    public static class StringExtensions
    {
        /// <summary>
        /// Aplica indentación (4 espacios por nivel) a cada línea del texto.
        /// </summary>
        /// <param name="text">Texto a indentar.</param>
        /// <param name="indentLevel">Nivel de indentación.</param>
        /// <returns>Texto con indentación aplicada.</returns>
        public static string Indent(this string text, int indentLevel)
        {
            string indent = new string(' ', indentLevel * 4);
            var lines = text.Split(new[] { Environment.NewLine }, StringSplitOptions.None);
            return string.Join(Environment.NewLine, lines.Select(line => indent + line));
        }
    }
}

7. Helpers/LogFormatter.cs

using System;
using System.Text;

namespace Logging.Helpers
{
    /// <summary>
    /// Contiene métodos estáticos para formatear bloques de log según el formato requerido.
    /// </summary>
    public static class LogFormatter
    {
        public static string FormatBeginLog()
        {
            var sb = new StringBuilder();
            sb.AppendLine("---------------------------Inicio de Log---------------------------");
            sb.AppendLine($"{DateTime.Now}");
            sb.AppendLine("---------------------------Inicio de Log---------------------------");
            sb.AppendLine();
            return sb.ToString();
        }
        
        public static string FormatEnvironmentInfoStart(
            string application,
            string env,
            string contentRoot,
            string executionId,
            string clientIp,
            string userAgent,
            string machineName,
            string os,
            string host,
            string distribution)
        {
            var sb = new StringBuilder();
            sb.AppendLine("---------------------------Enviroment Info-------------------------");
            sb.AppendLine($"       Inicio: {DateTime.Now}");
            sb.AppendLine("-------------------------------------------------------------------");
            sb.AppendLine($"Application: {application}");
            sb.AppendLine($"Environment: {env}");
            sb.AppendLine($"ContentRoot: {contentRoot}");
            sb.AppendLine($"Execution ID: {executionId}");
            sb.AppendLine($"Client IP: {clientIp}");
            sb.AppendLine($"User Agent: {userAgent}");
            sb.AppendLine($"Machine Name: {machineName}");
            sb.AppendLine($"OS: {os}");
            sb.AppendLine($"Host: {host}");
            sb.AppendLine($"Distribución: {distribution}");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatEnvironmentInfoEnd()
        {
            var sb = new StringBuilder();
            sb.AppendLine("----------------------------Enviroment Info-------------------------");
            sb.AppendLine($"       Fin: {DateTime.Now}");
            sb.AppendLine("-------------------------------------------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatEndpoint(string endpointName)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"---------------------------Endpoint: {endpointName}---------------------------");
            sb.AppendLine($"{DateTime.Now}");
            sb.AppendLine($"---------------------------Endpoint: {endpointName}---------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatRequestInfoStart()
        {
            var sb = new StringBuilder();
            sb.AppendLine("----------------------------------Request Info---------------------------------");
            sb.AppendLine($"       Inicio: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatRequestInfoEnd()
        {
            var sb = new StringBuilder();
            sb.AppendLine("----------------------------------Request Info---------------------------------");
            sb.AppendLine($"       Fin: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatSingleLog(string message)
        {
            var sb = new StringBuilder();
            sb.AppendLine("----------------------------------Single Log---------------------------------");
            sb.AppendLine($"       Inicio: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine(message);
            sb.AppendLine();
            sb.AppendLine("----------------------------------Single Log---------------------------------");
            sb.AppendLine($"       Fin: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatObjectLog(string objectName, string message)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"----------------------------------Object -> {objectName}---------------------------------");
            sb.AppendLine($"       Inicio: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine(message);
            sb.AppendLine();
            sb.AppendLine($"----------------------------------Object -> {objectName}---------------------------------");
            sb.AppendLine($"       Fin: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatMethodFunctionStart(string methodName)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"----------------------------------Método/Funcion : {methodName}---------------------------------");
            sb.AppendLine($"       Inicio: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatInputParameters(string parameters)
        {
            var sb = new StringBuilder();
            sb.AppendLine("-----------------------Parámetros de Entrada-----------------------------------");
            sb.AppendLine(parameters);
            sb.AppendLine("-----------------------Parámetros de Entrada-----------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatOutputParameters(string parameters)
        {
            var sb = new StringBuilder();
            sb.AppendLine("-----------------------Parámetros de Salida-----------------------------------");
            sb.AppendLine(parameters);
            sb.AppendLine("-----------------------Parámetros de Salida-----------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatMethodFunctionEnd(string methodName)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"----------------------------------Método/Funcion : {methodName}---------------------------------");
            sb.AppendLine($"       Fin: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatResponseInfo(string message)
        {
            var sb = new StringBuilder();
            sb.AppendLine("----------------------------------Response Info---------------------------------");
            sb.AppendLine($"       Inicio: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine(message);
            sb.AppendLine();
            sb.AppendLine("----------------------------------Response Info---------------------------------");
            sb.AppendLine($"       Fin: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatExceptionDetails(string message)
        {
            var sb = new StringBuilder();
            sb.AppendLine("----------------------------------Exception Details---------------------------------");
            sb.AppendLine($"       Inicio: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine(message);
            sb.AppendLine();
            sb.AppendLine("----------------------------------Exception Details---------------------------------");
            sb.AppendLine($"       Fin: {DateTime.Now}");
            sb.AppendLine("-----------------------------------------------------------------------------");
            sb.AppendLine();
            return sb.ToString();
        }

        public static string FormatEndLog()
        {
            var sb = new StringBuilder();
            sb.AppendLine("---------------------------Fin de Log---------------------------");
            sb.AppendLine($"{DateTime.Now}");
            sb.AppendLine("---------------------------Fin de Log---------------------------");
            return sb.ToString();
        }
    }
}

8. Helpers/LogScope.cs

using System;
using System.Threading;

namespace Logging.Helpers
{
    /// <summary>
    /// Permite crear un scope de logging anidado para mantener la jerarquía del flujo de ejecución.
    /// Utiliza AsyncLocal para mantener el nivel de indentación en operaciones asíncronas.
    /// </summary>
    public class LogScope : IDisposable
    {
        private static readonly AsyncLocal<int> _currentLevel = new AsyncLocal<int>();

        /// <summary>
        /// Obtiene el nivel actual de indentación.
        /// </summary>
        public static int CurrentLevel
        {
            get => _currentLevel.Value;
            private set => _currentLevel.Value = value;
        }

        /// <summary>
        /// Al instanciar un LogScope se incrementa el nivel actual.
        /// </summary>
        public LogScope()
        {
            CurrentLevel = CurrentLevel + 1;
        }

        /// <summary>
        /// Al finalizar el scope se decrementa el nivel actual.
        /// </summary>
        public void Dispose()
        {
            CurrentLevel = CurrentLevel - 1;
        }
    }
}

9. Middleware/LoggingMiddleware.cs

using Logging.Abstractions;
using Logging.Helpers;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Logging.Middleware
{
    /// <summary>
    /// Middleware que intercepta la solicitud y la respuesta para generar un log completo de la petición.
    /// </summary>
    public class LoggingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILoggingService _loggingService;
        private readonly IHostEnvironment _hostEnvironment;

        public LoggingMiddleware(RequestDelegate next, ILoggingService loggingService, IHostEnvironment hostEnvironment)
        {
            _next = next;
            _loggingService = loggingService;
            _hostEnvironment = hostEnvironment;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                // Definir el archivo único para la petición en la ruta: C:\Logs\[NombreApi]\
                var logFileName = Path.Combine(GetLogDirectory(), $"Log_{context.TraceIdentifier}.txt");
                context.Items["LogFileName"] = logFileName;

                var logBuilder = new StringBuilder();

                // Bloque de inicio del log
                logBuilder.AppendLine(LogFormatter.FormatBeginLog());

                // Datos dinámicos del ambiente con fallback a "Desconocido"
                string application = !string.IsNullOrWhiteSpace(_hostEnvironment.ApplicationName) ? _hostEnvironment.ApplicationName : "Desconocido";
                string env = !string.IsNullOrWhiteSpace(_hostEnvironment.EnvironmentName) ? _hostEnvironment.EnvironmentName : "Desconocido";
                string contentRoot = !string.IsNullOrWhiteSpace(_hostEnvironment.ContentRootPath) ? _hostEnvironment.ContentRootPath : "Desconocido";

                // Bloque de Environment Info
                logBuilder.AppendLine(LogFormatter.FormatEnvironmentInfoStart(
                    application: application,
                    env: env,
                    contentRoot: contentRoot,
                    executionId: context.TraceIdentifier,
                    clientIp: context.Connection.RemoteIpAddress?.ToString() ?? "Desconocido",
                    userAgent: context.Request.Headers["User-Agent"].FirstOrDefault() ?? "Desconocido",
                    machineName: Environment.MachineName,
                    os: Environment.OSVersion.ToString(),
                    host: context.Request.Host.ToString() ?? "Desconocido",
                    distribution: "Desconocido"
                ));
                logBuilder.AppendLine(LogFormatter.FormatEnvironmentInfoEnd());

                // Bloque de Endpoint
                string endpointName = context.Request.Path;
                logBuilder.AppendLine(LogFormatter.FormatEndpoint(endpointName));

                // Bloque de Request Info
                logBuilder.AppendLine(LogFormatter.FormatRequestInfoStart());
                logBuilder.AppendLine(await CaptureRequestInfoAsync(context));
                logBuilder.AppendLine(LogFormatter.FormatRequestInfoEnd());

                // Continuar con el pipeline
                await _next(context);

                // Bloque de Response Info
                logBuilder.AppendLine(LogFormatter.FormatResponseInfo(CaptureResponseInfo(context)));

                // Bloque de Endpoint al finalizar
                logBuilder.AppendLine(LogFormatter.FormatEndpoint(endpointName));

                // Bloque de Exception Details (si no hubo excepciones, se indica "Sin excepciones")
                logBuilder.AppendLine(LogFormatter.FormatExceptionDetails("Sin excepciones"));

                // Bloque de fin del log
                logBuilder.AppendLine(LogFormatter.FormatEndLog());

                // Escribir el log completo en el archivo único de la petición
                File.AppendAllText(logFileName, logBuilder.ToString());
            }
            catch (Exception ex)
            {
                // Si ocurre algún fallo en el middleware, se registra internamente.
                _loggingService.AddExceptionLog(ex);
            }
        }

        /// <summary>
        /// Obtiene la ruta de logs: C:\Logs\[NombreApi]\
        /// </summary>
        private string GetLogDirectory()
        {
            string apiName = !string.IsNullOrWhiteSpace(_hostEnvironment.ApplicationName)
                                ? _hostEnvironment.ApplicationName
                                : "Desconocido";
            string directory = Path.Combine(@"C:\Logs\", apiName);
            try
            {
                if (!Directory.Exists(directory))
                    Directory.CreateDirectory(directory);
            }
            catch (Exception ex)
            {
                _loggingService.AddExceptionLog(ex);
            }
            return directory;
        }

        private async Task<string> CaptureRequestInfoAsync(HttpContext context)
        {
            try
            {
                var request = context.Request;
                string headers = string.Join(Environment.NewLine, request.Headers.Select(h => $"{h.Key}: {h.Value}"));
                string query = request.QueryString.ToString();
                string ip = context.Connection.RemoteIpAddress?.ToString() ?? "Desconocido";
                string method = request.Method;
                string body = string.Empty;

                request.EnableBuffering();
                using (var reader = new StreamReader(request.Body, leaveOpen: true))
                {
                    body = await reader.ReadToEndAsync();
                    request.Body.Position = 0;
                }

                var sb = new StringBuilder();
                sb.AppendLine($"IP: {ip}");
                sb.AppendLine($"Method: {method}");
                sb.AppendLine($"Query: {query}");
                sb.AppendLine($"Headers: {headers}");
                sb.AppendLine("Body: ");
                sb.AppendLine(body);
                return sb.ToString();
            }
            catch
            {
                return "No se pudo capturar la información de la solicitud.";
            }
        }

        private string CaptureResponseInfo(HttpContext context)
        {
            try
            {
                var response = context.Response;
                string headers = string.Join(Environment.NewLine, response.Headers.Select(h => $"{h.Key}: {h.Value}"));
                return $"StatusCode: {response.StatusCode}{Environment.NewLine}Headers: {headers}";
            }
            catch
            {
                return "No se pudo capturar la información de la respuesta.";
            }
        }
    }
}

10. Filters/LoggingActionFilter.cs

using Logging.Abstractions;
using Logging.Helpers;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Controllers;
using System.Diagnostics;
using System.Linq;
using System.Text.Json;

namespace Logging.Filters
{
    /// <summary>
    /// Filtro de acción para registrar el flujo de ejecución en los controladores.
    /// Captura parámetros de entrada y salida, y mide el tiempo de ejecución.
    /// </summary>
    public class LoggingActionFilter : IActionFilter
    {
        private readonly ILoggingService _loggingService;
        private readonly string _controllerName;
        private readonly string _actionName;
        private Stopwatch _stopwatch;

        public LoggingActionFilter(ILoggingService loggingService, ActionDescriptor actionDescriptor)
        {
            _loggingService = loggingService;
            _controllerName = actionDescriptor.RouteValues["controller"];
            _actionName = actionDescriptor.RouteValues["action"];
        }

        public void OnActionExecuting(ActionExecutingContext context)
        {
            try
            {
                // Crear un scope para este método
                using (new LogScope())
                {
                    _stopwatch = Stopwatch.StartNew();
                    // Registrar parámetros de entrada (obtenidos dinámicamente)
                    var inputParams = string.Join(System.Environment.NewLine,
                        context.ActionArguments.Select(arg => $"{arg.Key} = {(arg.Value != null ? JsonSerializer.Serialize(arg.Value, new JsonSerializerOptions { WriteIndented = true }) : "Desconocido") }"));
                    _loggingService.AddInputParameters(inputParams);
                    _loggingService.AddSingleLog($"Inicio de ejecución en Controller: {_controllerName}, Action: {_actionName}");
                }
            }
            catch { }
        }

        public void OnActionExecuted(ActionExecutedContext context)
        {
            try
            {
                using (new LogScope())
                {
                    _stopwatch.Stop();
                    // Registrar salida: si es ObjectResult se serializa el valor
                    string outputParams = "Sin datos de salida";
                    if (context.Result is ObjectResult objectResult && objectResult.Value != null)
                    {
                        outputParams = JsonSerializer.Serialize(objectResult.Value, new JsonSerializerOptions { WriteIndented = true });
                    }
                    _loggingService.AddOutputParameters(outputParams);
                    _loggingService.AddSingleLog($"Fin de ejecución en Controller: {_controllerName}, Action: {_actionName} en {_stopwatch.ElapsedMilliseconds} ms");
                }
            }
            catch { }
        }
    }
}

11. Services/LoggingService.cs

using Logging.Abstractions;
using Logging.Extensions;
using Logging.Helpers;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using System;
using System.IO;
using System.Text;
using System.Text.Json;

namespace Logging.Services
{
    /// <summary>
    /// Implementación del servicio de logging.
    /// Escribe logs en archivos únicos por petición utilizando la ruta: C:\Logs\[NombreApi]\.
    /// Maneja internamente errores escribiéndolos en "InternalErrorLog.txt" sin afectar la API.
    /// </summary>
    public class LoggingService : ILoggingService
    {
        // La ruta base se determina dinámicamente: C:\Logs\[NombreApi]\
        private readonly string _logDirectory;
        private readonly IHttpContextAccessor _httpContextAccessor;

        /// <summary>
        /// Versión de la librería para control de versionamiento.
        /// </summary>
        public const string LibraryVersion = "1.0.0";

        public LoggingService(IHttpContextAccessor httpContextAccessor, IHostEnvironment hostEnvironment)
        {
            _httpContextAccessor = httpContextAccessor;
            // Obtener el nombre de la API desde el entorno; si no está definido se usa "Desconocido"
            string apiName = !string.IsNullOrWhiteSpace(hostEnvironment.ApplicationName) 
                                ? hostEnvironment.ApplicationName 
                                : "Desconocido";
            _logDirectory = Path.Combine(@"C:\Logs\", apiName);
            try
            {
                if (!Directory.Exists(_logDirectory))
                    Directory.CreateDirectory(_logDirectory);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Obtiene el archivo de log actual asociado a la petición o un archivo global en caso de ausencia.
        /// </summary>
        private string GetCurrentLogFile()
        {
            try
            {
                var context = _httpContextAccessor.HttpContext;
                if (context != null && context.Items.ContainsKey("LogFileName"))
                {
                    return context.Items["LogFileName"] as string;
                }
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
            return Path.Combine(_logDirectory, "GlobalManualLogs.txt");
        }

        /// <summary>
        /// Registra un error interno en el archivo InternalErrorLog.txt.
        /// </summary>
        private void LogInternalError(Exception ex)
        {
            try
            {
                var errorLogPath = Path.Combine(_logDirectory, "InternalErrorLog.txt");
                var errorMessage = $"[{DateTime.Now}] Error en LoggingService: {ex}{Environment.NewLine}";
                File.AppendAllText(errorLogPath, errorMessage);
            }
            catch
            {
                // Si falla, se ignora para evitar ciclos de error.
            }
        }

        public void WriteLog(HttpContext context, string logContent)
        {
            try
            {
                var fileName = Path.Combine(_logDirectory, $"Log_{context.TraceIdentifier}.txt");
                File.AppendAllText(fileName, logContent.Indent(LogScope.CurrentLevel) + Environment.NewLine + Environment.NewLine);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddSingleLog(string logMessage)
        {
            try
            {
                var formatted = LogFormatter.FormatSingleLog(logMessage).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddObjLog(string objectName, object logObject)
        {
            try
            {
                string logContent = JsonSerializer.Serialize(logObject, new JsonSerializerOptions { WriteIndented = true });
                var formatted = LogFormatter.FormatObjectLog(objectName, logContent).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddResponseLog(string logMessage)
        {
            try
            {
                var formatted = LogFormatter.FormatResponseInfo(logMessage).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddEnvironmentLog(string logMessage)
        {
            try
            {
                var sb = new StringBuilder();
                sb.AppendLine(LogFormatter.FormatEnvironmentInfoStart(
                    application: GetValueOrDefault(() => _httpContextAccessor.HttpContext.RequestServices.GetService(typeof(IHostEnvironment)) as IHostEnvironment)?.ApplicationName ?? "Desconocido",
                    env: GetValueOrDefault(() => _httpContextAccessor.HttpContext.RequestServices.GetService(typeof(IHostEnvironment)) as IHostEnvironment)?.EnvironmentName ?? "Desconocido",
                    contentRoot: GetValueOrDefault(() => _httpContextAccessor.HttpContext.RequestServices.GetService(typeof(IHostEnvironment)) as IHostEnvironment)?.ContentRootPath ?? "Desconocido",
                    executionId: _httpContextAccessor.HttpContext?.TraceIdentifier ?? "Desconocido",
                    clientIp: _httpContextAccessor.HttpContext?.Connection.RemoteIpAddress?.ToString() ?? "Desconocido",
                    userAgent: _httpContextAccessor.HttpContext?.Request.Headers["User-Agent"].ToString() ?? "Desconocido",
                    machineName: Environment.MachineName,
                    os: Environment.OSVersion.ToString(),
                    host: _httpContextAccessor.HttpContext?.Request.Host.ToString() ?? "Desconocido",
                    distribution: "Desconocido"
                ));
                sb.AppendLine(logMessage);
                sb.AppendLine(LogFormatter.FormatEnvironmentInfoEnd());
                File.AppendAllText(GetCurrentLogFile(), sb.ToString().Indent(LogScope.CurrentLevel));
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddExceptionLog(Exception ex)
        {
            try
            {
                var formatted = LogFormatter.FormatExceptionDetails(ex?.ToString() ?? "Sin excepciones").Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception e)
            {
                LogInternalError(e);
            }
        }

        public void AddInputParameters(string parameters)
        {
            try
            {
                var formatted = LogFormatter.FormatInputParameters(parameters).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddOutputParameters(string parameters)
        {
            try
            {
                var formatted = LogFormatter.FormatOutputParameters(parameters).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Función auxiliar para obtener un valor con manejo de excepción.
        /// Retorna el valor obtenido o el valor por defecto si ocurre algún error.
        /// </summary>
        private T GetValueOrDefault<T>(Func<T> getter)
        {
            try
            {
                return getter();
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
                return default;
            }
        }
    }
}

Con estos archivos ya tienes la solución completa de la librería "MyCompany.Logging". Puedes copiar cada archivo en su respectiva ubicación y luego comprimir la carpeta "MyCompany.Logging" en un archivo ZIP para su distribución.

Si necesitas algún otro ajuste o aclaración, ¡hazmelo saber!