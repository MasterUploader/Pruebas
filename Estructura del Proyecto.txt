namespace Logging.Configuration
{
    /// <summary>
    /// Opciones de configuración para la librería de Logging.
    /// Se pueden configurar desde el appsettings.json de la API consumidora.
    /// </summary>
    public class LoggingOptions
    {
        /// <summary>
        /// Ruta base para almacenar los logs.
        /// Por defecto se establece "C:\Logs\".
        /// </summary>
        public string BaseLogDirectory { get; set; } = @"C:\Logs\";
    }
}




using Logging.Abstractions;
using Logging.Configuration;
using Logging.Extensions;
using Logging.Helpers;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using System;
using System.IO;
using System.Text;
using System.Text.Json;

namespace Logging.Services
{
    /// <summary>
    /// Implementación del servicio de logging.
    /// Escribe logs en archivos únicos por petición utilizando la ruta:
    /// [BaseLogDirectory]\[NombreApi]\, donde BaseLogDirectory se configura desde el appsettings.json.
    /// Maneja internamente errores escribiéndolos en "InternalErrorLog.txt" sin afectar la API.
    /// </summary>
    public class LoggingService : ILoggingService
    {
        private readonly string _logDirectory;
        private readonly IHttpContextAccessor _httpContextAccessor;

        /// <summary>
        /// Versión de la librería para control de versionamiento.
        /// </summary>
        public const string LibraryVersion = "1.0.0";

        /// <summary>
        /// Constructor que obtiene la ruta base de logs desde la configuración.
        /// </summary>
        /// <param name="httpContextAccessor">Acceso al HttpContext.</param>
        /// <param name="hostEnvironment">Información del entorno de la aplicación.</param>
        /// <param name="options">Opciones de configuración para el logging.</param>
        public LoggingService(IHttpContextAccessor httpContextAccessor, IHostEnvironment hostEnvironment, IOptions<LoggingOptions> options)
        {
            _httpContextAccessor = httpContextAccessor;
            // Se obtiene la ruta base desde la configuración (appsettings.json)
            string baseLogDir = options.Value.BaseLogDirectory;
            // Se obtiene el nombre de la API del entorno; si no está definido se usa "Desconocido"
            string apiName = !string.IsNullOrWhiteSpace(hostEnvironment.ApplicationName) ? hostEnvironment.ApplicationName : "Desconocido";
            _logDirectory = Path.Combine(baseLogDir, apiName);
            try
            {
                if (!Directory.Exists(_logDirectory))
                    Directory.CreateDirectory(_logDirectory);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Obtiene el archivo de log actual asociado a la petición o un archivo global en caso de ausencia.
        /// </summary>
        private string GetCurrentLogFile()
        {
            try
            {
                var context = _httpContextAccessor.HttpContext;
                if (context != null && context.Items.ContainsKey("LogFileName"))
                {
                    return context.Items["LogFileName"] as string;
                }
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
            return Path.Combine(_logDirectory, "GlobalManualLogs.txt");
        }

        /// <summary>
        /// Registra un error interno en el archivo InternalErrorLog.txt.
        /// </summary>
        private void LogInternalError(Exception ex)
        {
            try
            {
                var errorLogPath = Path.Combine(_logDirectory, "InternalErrorLog.txt");
                var errorMessage = $"[{DateTime.Now}] Error en LoggingService: {ex}{Environment.NewLine}";
                File.AppendAllText(errorLogPath, errorMessage);
            }
            catch
            {
                // Si falla, se ignora para evitar ciclos de error.
            }
        }

        public void WriteLog(HttpContext context, string logContent)
        {
            try
            {
                var fileName = Path.Combine(_logDirectory, $"Log_{context.TraceIdentifier}.txt");
                File.AppendAllText(fileName, logContent.Indent(LogScope.CurrentLevel) + Environment.NewLine + Environment.NewLine);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddSingleLog(string logMessage)
        {
            try
            {
                var formatted = LogFormatter.FormatSingleLog(logMessage).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddObjLog(string objectName, object logObject)
        {
            try
            {
                string logContent = JsonSerializer.Serialize(logObject, new JsonSerializerOptions { WriteIndented = true });
                var formatted = LogFormatter.FormatObjectLog(objectName, logContent).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddResponseLog(string logMessage)
        {
            try
            {
                var formatted = LogFormatter.FormatResponseInfo(logMessage).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddEnvironmentLog(string logMessage)
        {
            try
            {
                var sb = new StringBuilder();
                sb.AppendLine(LogFormatter.FormatEnvironmentInfoStart(
                    application: GetValueOrDefault(() => _httpContextAccessor.HttpContext.RequestServices.GetService(typeof(IHostEnvironment)) as IHostEnvironment)?.ApplicationName ?? "Desconocido",
                    env: GetValueOrDefault(() => _httpContextAccessor.HttpContext.RequestServices.GetService(typeof(IHostEnvironment)) as IHostEnvironment)?.EnvironmentName ?? "Desconocido",
                    contentRoot: GetValueOrDefault(() => _httpContextAccessor.HttpContext.RequestServices.GetService(typeof(IHostEnvironment)) as IHostEnvironment)?.ContentRootPath ?? "Desconocido",
                    executionId: _httpContextAccessor.HttpContext?.TraceIdentifier ?? "Desconocido",
                    clientIp: _httpContextAccessor.HttpContext?.Connection.RemoteIpAddress?.ToString() ?? "Desconocido",
                    userAgent: _httpContextAccessor.HttpContext?.Request.Headers["User-Agent"].ToString() ?? "Desconocido",
                    machineName: Environment.MachineName,
                    os: Environment.OSVersion.ToString(),
                    host: _httpContextAccessor.HttpContext?.Request.Host.ToString() ?? "Desconocido",
                    distribution: "Desconocido"
                ));
                sb.AppendLine(logMessage);
                sb.AppendLine(LogFormatter.FormatEnvironmentInfoEnd());
                File.AppendAllText(GetCurrentLogFile(), sb.ToString().Indent(LogScope.CurrentLevel));
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddExceptionLog(Exception ex)
        {
            try
            {
                var formatted = LogFormatter.FormatExceptionDetails(ex?.ToString() ?? "Sin excepciones").Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception e)
            {
                LogInternalError(e);
            }
        }

        public void AddInputParameters(string parameters)
        {
            try
            {
                var formatted = LogFormatter.FormatInputParameters(parameters).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        public void AddOutputParameters(string parameters)
        {
            try
            {
                var formatted = LogFormatter.FormatOutputParameters(parameters).Indent(LogScope.CurrentLevel);
                File.AppendAllText(GetCurrentLogFile(), formatted);
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
            }
        }

        /// <summary>
        /// Función auxiliar para obtener un valor con manejo de excepción.
        /// Retorna el valor obtenido o el valor por defecto si ocurre algún error.
        /// </summary>
        private T GetValueOrDefault<T>(Func<T> getter)
        {
            try
            {
                return getter();
            }
            catch (Exception ex)
            {
                LogInternalError(ex);
                return default;
            }
        }
    }
}
