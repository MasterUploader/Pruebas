using Logging.Abstractions;
using Logging.Helpers;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Logging.Middleware
{
    /// <summary>
    /// Middleware que intercepta la solicitud (request) y la respuesta (response) para generar un log completo
    /// de la petición actual. El log se escribe en un archivo único ubicado en la ruta:
    /// [BaseLogDirectory]\[NombreApi]\, donde BaseLogDirectory se configura desde el appsettings.json 
    /// y el NombreApi se obtiene dinámicamente del entorno (IHostEnvironment).
    /// </summary>
    public class LoggingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILoggingService _loggingService;
        private readonly IHostEnvironment _hostEnvironment;

        /// <summary>
        /// Constructor del middleware que inyecta el RequestDelegate, el servicio de logging y la información del entorno.
        /// </summary>
        /// <param name="next">Siguiente middleware en el pipeline.</param>
        /// <param name="loggingService">Servicio para registrar logs.</param>
        /// <param name="hostEnvironment">Información del entorno de la aplicación.</param>
        public LoggingMiddleware(RequestDelegate next, ILoggingService loggingService, IHostEnvironment hostEnvironment)
        {
            _next = next;
            _loggingService = loggingService;
            _hostEnvironment = hostEnvironment;
        }

        /// <summary>
        /// Método principal del middleware que se invoca para cada solicitud.
        /// Genera un log completo que incluye información del entorno, endpoint, request, response y excepciones.
        /// </summary>
        /// <param name="context">El contexto HTTP de la petición actual.</param>
        /// <returns>Una tarea asincrónica.</returns>
        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                // Obtiene la ruta de logs basada en el nombre de la API (definida en el entorno)
                var logFileName = Path.Combine(GetLogDirectory(), $"Log_{context.TraceIdentifier}.txt");
                // Almacena el nombre del archivo de log en el HttpContext para que otros métodos lo puedan utilizar
                context.Items["LogFileName"] = logFileName;

                var logBuilder = new StringBuilder();

                // Genera el bloque de inicio del log
                logBuilder.AppendLine(LogFormatter.FormatBeginLog());

                // Recupera datos dinámicos del entorno: ApplicationName, EnvironmentName y ContentRootPath.
                string application = !string.IsNullOrWhiteSpace(_hostEnvironment.ApplicationName) ? _hostEnvironment.ApplicationName : "Desconocido";
                string env = !string.IsNullOrWhiteSpace(_hostEnvironment.EnvironmentName) ? _hostEnvironment.EnvironmentName : "Desconocido";
                string contentRoot = !string.IsNullOrWhiteSpace(_hostEnvironment.ContentRootPath) ? _hostEnvironment.ContentRootPath : "Desconocido";

                // Genera el bloque de información del entorno con datos como la IP del cliente, User-Agent, etc.
                logBuilder.AppendLine(LogFormatter.FormatEnvironmentInfoStart(
                    application: application,
                    env: env,
                    contentRoot: contentRoot,
                    executionId: context.TraceIdentifier,
                    clientIp: context.Connection.RemoteIpAddress?.ToString() ?? "Desconocido",
                    userAgent: context.Request.Headers["User-Agent"].FirstOrDefault() ?? "Desconocido",
                    machineName: Environment.MachineName,
                    os: Environment.OSVersion.ToString(),
                    host: context.Request.Host.ToString() ?? "Desconocido",
                    distribution: "Desconocido"
                ));
                logBuilder.AppendLine(LogFormatter.FormatEnvironmentInfoEnd());

                // Registra el endpoint (ruta) que se está procesando
                string endpointName = context.Request.Path;
                logBuilder.AppendLine(LogFormatter.FormatEndpoint(endpointName));

                // Captura y registra la información de la solicitud (request)
                logBuilder.AppendLine(LogFormatter.FormatRequestInfoStart());
                logBuilder.AppendLine(await CaptureRequestInfoAsync(context));
                logBuilder.AppendLine(LogFormatter.FormatRequestInfoEnd());

                // Invoca el siguiente middleware en el pipeline (o la acción del controlador)
                await _next(context);

                // Captura y registra la información de la respuesta (response)
                logBuilder.AppendLine(LogFormatter.FormatResponseInfo(CaptureResponseInfo(context)));

                // Registra nuevamente el endpoint para marcar el fin del procesamiento de ese endpoint
                logBuilder.AppendLine(LogFormatter.FormatEndpoint(endpointName));

                // Registra el bloque de excepciones; en este caso, se indica "Sin excepciones" si todo fue correcto.
                logBuilder.AppendLine(LogFormatter.FormatExceptionDetails("Sin excepciones"));

                // Agrega el bloque final de cierre del log
                logBuilder.AppendLine(LogFormatter.FormatEndLog());

                // Escribe todo el contenido generado en el archivo único para esta petición.
                File.AppendAllText(logFileName, logBuilder.ToString());
            }
            catch (Exception ex)
            {
                // Si ocurre alguna excepción en el middleware, se registra en el log de excepciones utilizando el servicio.
                _loggingService.AddExceptionLog(ex);
            }
        }

        /// <summary>
        /// Obtiene la ruta de directorio para guardar los logs en función del nombre de la API.
        /// La ruta se forma como "C:\Logs\[NombreApi]\".
        /// </summary>
        /// <returns>La ruta completa del directorio de logs.</returns>
        private string GetLogDirectory()
        {
            // Obtiene el nombre de la API desde el entorno; usa "Desconocido" si no está definido.
            string apiName = !string.IsNullOrWhiteSpace(_hostEnvironment.ApplicationName)
                                ? _hostEnvironment.ApplicationName
                                : "Desconocido";
            // Combina la ruta base fija con el nombre de la API.
            string directory = Path.Combine(@"C:\Logs\", apiName);
            try
            {
                // Crea el directorio si no existe.
                if (!Directory.Exists(directory))
                    Directory.CreateDirectory(directory);
            }
            catch (Exception ex)
            {
                // Registra cualquier error al crear el directorio.
                _loggingService.AddExceptionLog(ex);
            }
            return directory;
        }

        /// <summary>
        /// Captura la información relevante de la solicitud (request), incluyendo:
        /// IP, método, query string, headers y body.
        /// Si ocurre un error, retorna un mensaje predeterminado.
        /// </summary>
        /// <param name="context">El HttpContext de la solicitud.</param>
        /// <returns>Una cadena con la información de la solicitud.</returns>
        private async Task<string> CaptureRequestInfoAsync(HttpContext context)
        {
            try
            {
                var request = context.Request;
                // Combina todos los headers en una cadena, separándolos por salto de línea.
                string headers = string.Join(Environment.NewLine, request.Headers.Select(h => $"{h.Key}: {h.Value}"));
                // Obtiene la query string
                string query = request.QueryString.ToString();
                // Obtiene la dirección IP del cliente
                string ip = context.Connection.RemoteIpAddress?.ToString() ?? "Desconocido";
                // Obtiene el método HTTP (GET, POST, etc.)
                string method = request.Method;
                string body = string.Empty;

                // Habilita el buffer para poder leer el body sin consumirlo
                request.EnableBuffering();
                using (var reader = new StreamReader(request.Body, leaveOpen: true))
                {
                    body = await reader.ReadToEndAsync();
                    // Restaura la posición del stream para que otros componentes puedan leerlo
                    request.Body.Position = 0;
                }

                var sb = new StringBuilder();
                sb.AppendLine($"IP: {ip}");
                sb.AppendLine($"Method: {method}");
                sb.AppendLine($"Query: {query}");
                sb.AppendLine($"Headers: {headers}");
                sb.AppendLine("Body: ");
                sb.AppendLine(body);
                return sb.ToString();
            }
            catch
            {
                return "No se pudo capturar la información de la solicitud.";
            }
        }

        /// <summary>
        /// Captura la información de la respuesta (response), incluyendo el código de estado y headers.
        /// Si ocurre un error, retorna un mensaje predeterminado.
        /// </summary>
        /// <param name="context">El HttpContext de la respuesta.</param>
        /// <returns>Una cadena con la información de la respuesta.</returns>
        private string CaptureResponseInfo(HttpContext context)
        {
            try
            {
                var response = context.Response;
                // Combina todos los headers de la respuesta en una cadena.
                string headers = string.Join(Environment.NewLine, response.Headers.Select(h => $"{h.Key}: {h.Value}"));
                return $"StatusCode: {response.StatusCode}{Environment.NewLine}Headers: {headers}";
            }
            catch
            {
                return "No se pudo capturar la información de la respuesta.";
            }
        }
    }
}
