using Logging.Abstractions;
using Logging.Helpers;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Controllers;
using System.Diagnostics;
using System.Linq;
using System.Text.Json;

namespace Logging.Filters
{
    /// <summary>
    /// Filtro de acción que se ejecuta antes y después de la acción de un controlador.
    /// Captura parámetros de entrada y salida, y mide el tiempo de ejecución.
    /// Utiliza scopes anidados para reflejar la jerarquía del flujo de ejecución.
    /// </summary>
    public class LoggingActionFilter : IActionFilter
    {
        private readonly ILoggingService _loggingService;
        private readonly string _controllerName;
        private readonly string _actionName;
        private Stopwatch _stopwatch;

        // Reutiliza una instancia estática para las opciones de serialización, evitando crear nuevas instancias en cada uso.
        private static readonly JsonSerializerOptions SerializerOptions = new JsonSerializerOptions { WriteIndented = true };

        /// <summary>
        /// Constructor que inicializa el filtro con el servicio de logging y extrae los nombres del controlador y de la acción.
        /// </summary>
        /// <param name="loggingService">Servicio de logging inyectado.</param>
        /// <param name="actionDescriptor">Descriptor de la acción, del cual se extraen el controlador y la acción.</param>
        public LoggingActionFilter(ILoggingService loggingService, ActionDescriptor actionDescriptor)
            => (_loggingService, _controllerName, _actionName) =
                (loggingService, actionDescriptor.RouteValues["controller"], actionDescriptor.RouteValues["action"]);

        /// <summary>
        /// Se ejecuta antes de que se invoque la acción del controlador.
        /// Inicia el cronómetro, registra los parámetros de entrada y envía un log indicando el inicio de la ejecución.
        /// </summary>
        /// <param name="context">Contexto de ejecución de la acción.</param>
        public void OnActionExecuting(ActionExecutingContext context)
        {
            try
            {
                // Se crea un scope para aumentar la indentación y reflejar el inicio de un bloque de ejecución.
                using var scope = new LogScope();

                // Inicia el cronómetro para medir el tiempo de ejecución.
                _stopwatch = Stopwatch.StartNew();

                // Serializa los parámetros de entrada, reutilizando las opciones definidas.
                var inputParams = string.Join(System.Environment.NewLine,
                    context.ActionArguments.Select(arg =>
                        $"{arg.Key} = {(arg.Value != null ? JsonSerializer.Serialize(arg.Value, SerializerOptions) : "Desconocido") }"));

                // Registra los parámetros de entrada.
                _loggingService.AddInputParameters(inputParams);
                // Registra un log indicando el inicio de la ejecución en el controlador y acción correspondientes.
                _loggingService.AddSingleLog($"Inicio de ejecución en Controller: {_controllerName}, Action: {_actionName}");
            }
            catch (System.Exception ex)
            {
                // Si ocurre alguna excepción, se registra usando el servicio de logging.
                _loggingService.AddExceptionLog(ex);
            }
        }

        /// <summary>
        /// Se ejecuta después de que se ha invocado la acción del controlador.
        /// Detiene el cronómetro, registra los parámetros de salida y envía un log final indicando el tiempo de ejecución.
        /// </summary>
        /// <param name="context">Contexto de ejecución de la acción, incluyendo el resultado.</param>
        public void OnActionExecuted(ActionExecutedContext context)
        {
            try
            {
                using var scope = new LogScope();

                // Detiene el cronómetro y obtiene el tiempo transcurrido.
                _stopwatch.Stop();

                // Intenta capturar el resultado de la acción; si es un ObjectResult, se serializa el valor.
                string outputParams = "Sin datos de salida";
                if (context.Result is ObjectResult objectResult && objectResult.Value != null)
                {
                    outputParams = JsonSerializer.Serialize(objectResult.Value, SerializerOptions);
                }

                // Registra los parámetros de salida.
                _loggingService.AddOutputParameters(outputParams);
                // Registra un log indicando el fin de la ejecución, junto con el tiempo transcurrido.
                _loggingService.AddSingleLog($"Fin de ejecución en Controller: {_controllerName}, Action: {_actionName} en {_stopwatch.ElapsedMilliseconds} ms");
            }
            catch (System.Exception ex)
            {
                // En caso de error, se registra la excepción.
                _loggingService.AddExceptionLog(ex);
            }
        }
    }
}
