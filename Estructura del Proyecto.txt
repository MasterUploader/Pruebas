/// <summary>
    /// Filtro de acción que se ejecuta antes y después de la ejecución de una acción en un controlador.
    /// Captura información como parámetros de entrada y salida, tiempos de ejecución y errores.
    /// </summary>
    public class LoggingActionFilter(ILoggingService loggingService) : IActionFilter
    {
        /// <summary>
        /// Nombre del controlador en ejecución.
        /// Se inicializa en el constructor y se actualiza en `OnActionExecuting()`.
        /// </summary>
        private string ControllerName { get; set; }

        /// <summary>
        /// Nombre de la acción en ejecución.
        /// Se inicializa en el constructor y se actualiza en `OnActionExecuting()`.
        /// </summary>
        private string ActionName { get; set; }

        /// <summary>
        /// Cronómetro utilizado para medir el tiempo de ejecución de la acción.
        /// Se inicializa cuando la acción comienza a ejecutarse.
        /// </summary>
        private Stopwatch? _stopwatch;

        /// <summary>
        /// Instancia estática de JsonSerializerOptions para evitar creaciones innecesarias.
        /// Se usa para serializar objetos en los logs con formato legible.
        /// </summary>
        private static readonly JsonSerializerOptions SerializerOptions = new() { WriteIndented = true };

        /// <summary>
        /// Constructor principal que inicializa los nombres del controlador y la acción con valores predeterminados.
        /// </summary>
        /// <param name="loggingService">Servicio de logging utilizado para registrar la ejecución.</param>
        public LoggingActionFilter(ILoggingService loggingService) : this(loggingService, "Desconocido", "Desconocido") { }

        /// <summary>
        /// Constructor privado que permite inicializar los valores del controlador y la acción.
        /// </summary>
        /// <param name="loggingService">Servicio de logging.</param>
        /// <param name="controllerName">Nombre del controlador.</param>
        /// <param name="actionName">Nombre de la acción.</param>
        private LoggingActionFilter(ILoggingService loggingService, string controllerName, string actionName)
        {
            ControllerName = controllerName;
            ActionName = actionName;
        }

        /// <summary>
        /// Se ejecuta antes de que la acción del controlador comience a ejecutarse.
        /// Registra los parámetros de entrada y la información de inicio.
        /// </summary>
        /// <param name="context">Contexto de ejecución de la acción, contiene la información de la solicitud.</param>
        public void OnActionExecuting(ActionExecutingContext context)
        {
            try
            {
                // Inicia un nuevo scope de log para reflejar la jerarquía de ejecución.
                using var scope = new LogScope();

                // Inicia el cronómetro para medir el tiempo de ejecución de la acción.
                _stopwatch = Stopwatch.StartNew();

                // Obtiene el nombre del controlador y la acción desde el contexto.
                ControllerName = context.ActionDescriptor.RouteValues["controller"] ?? "Desconocido";
                ActionName = context.ActionDescriptor.RouteValues["action"] ?? "Desconocido";

                // Serializa los parámetros de entrada en formato JSON legible.
                var inputParams = string.Join(System.Environment.NewLine,
                    context.ActionArguments.Select(arg =>
                        $"{arg.Key} = {(arg.Value != null ? JsonSerializer.Serialize(arg.Value, SerializerOptions) : "Desconocido") }"));

                // Registra los parámetros de entrada en el log.
                _loggingService.AddInputParameters(inputParams);

                // Registra el inicio de ejecución de la acción en el log.
                _loggingService.AddSingleLog($"Inicio de ejecución en Controller: {ControllerName}, Action: {ActionName}");
            }
            catch (System.Exception ex)
            {
                // Si ocurre un error durante el proceso, se captura y se registra.
                _loggingService.AddExceptionLog(ex);
            }
        }

        /// <summary>
        /// Se ejecuta después de que la acción del controlador ha terminado.
        /// Registra los parámetros de salida, el tiempo de ejecución y la información de finalización.
        /// </summary>
        /// <param name="context">Contexto de ejecución de la acción, contiene el resultado de la acción.</param>
        public void OnActionExecuted(ActionExecutedContext context)
        {
            try
            {
                // Inicia un nuevo scope de log para reflejar la jerarquía de ejecución.
                using var scope = new LogScope();

                // Si el cronómetro fue iniciado, lo detiene para calcular el tiempo de ejecución.
                _stopwatch?.Stop();

                // Captura el resultado de la acción si es un ObjectResult (respuesta con datos).
                string outputParams = "Sin datos de salida";
                if (context.Result is ObjectResult objectResult && objectResult.Value != null)
                {
                    outputParams = JsonSerializer.Serialize(objectResult.Value, SerializerOptions);
                }

                // Registra los parámetros de salida en el log.
                _loggingService.AddOutputParameters(outputParams);

                // Registra el final de la ejecución de la acción con el tiempo transcurrido en milisegundos.
                _loggingService.AddSingleLog($"Fin de ejecución en Controller: {ControllerName}, Action: {ActionName} en {_stopwatch?.ElapsedMilliseconds ?? 0} ms");
            }
            catch (System.Exception ex)
            {
                // Si ocurre un error durante el proceso, se captura y se registra.
                _loggingService.AddExceptionLog(ex);
            }
        }
    }

