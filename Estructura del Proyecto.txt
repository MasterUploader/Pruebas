using Logging.Abstractions;
using Logging.Configuration;
using Logging.Helpers;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Logging.Middleware
{
    /// <summary>
    /// Middleware que intercepta la solicitud y la respuesta para generar un log completo.
    /// La ruta base para almacenar los logs se obtiene desde la configuración (LoggingOptions) del API.
    /// </summary>
    public class LoggingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILoggingService _loggingService;
        private readonly IHostEnvironment _hostEnvironment;
        // Ruta base configurada para logs (por ejemplo, "C:\Logs\")
        private readonly string _baseLogDirectory;

        /// <summary>
        /// Constructor del middleware.
        /// Se inyectan el siguiente middleware, el servicio de logging, el entorno y las opciones de configuración.
        /// </summary>
        /// <param name="next">Siguiente middleware en el pipeline.</param>
        /// <param name="loggingService">Servicio para registrar logs.</param>
        /// <param name="hostEnvironment">Información del entorno de la aplicación.</param>
        /// <param name="options">Opciones de configuración que contienen la ruta base para los logs.</param>
        public LoggingMiddleware(
            RequestDelegate next, 
            ILoggingService loggingService, 
            IHostEnvironment hostEnvironment,
            IOptions<LoggingOptions> options)
        {
            _next = next;
            _loggingService = loggingService;
            _hostEnvironment = hostEnvironment;
            _baseLogDirectory = !string.IsNullOrWhiteSpace(options.Value.BaseLogDirectory)
                                    ? options.Value.BaseLogDirectory
                                    : @"C:\Logs\";
        }

        /// <summary>
        /// Método principal del middleware que genera el log completo para la petición.
        /// </summary>
        /// <param name="context">Contexto HTTP de la petición.</param>
        /// <returns>Tarea asincrónica.</returns>
        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                // Se obtiene el archivo de log para la petición actual, combinando la ruta base y el nombre de la API.
                var logFileName = Path.Combine(GetLogDirectory(), $"Log_{context.TraceIdentifier}.txt");
                context.Items["LogFileName"] = logFileName;

                var logBuilder = new StringBuilder();

                // Se agrega el bloque de inicio del log.
                logBuilder.AppendLine(LogFormatter.FormatBeginLog());

                // Se obtienen datos del entorno del host.
                string application = !string.IsNullOrWhiteSpace(_hostEnvironment.ApplicationName) ? _hostEnvironment.ApplicationName : "Desconocido";
                string env = !string.IsNullOrWhiteSpace(_hostEnvironment.EnvironmentName) ? _hostEnvironment.EnvironmentName : "Desconocido";
                string contentRoot = !string.IsNullOrWhiteSpace(_hostEnvironment.ContentRootPath) ? _hostEnvironment.ContentRootPath : "Desconocido";

                // Se registra el bloque de información del entorno.
                logBuilder.AppendLine(LogFormatter.FormatEnvironmentInfoStart(
                    application: application,
                    env: env,
                    contentRoot: contentRoot,
                    executionId: context.TraceIdentifier,
                    clientIp: context.Connection.RemoteIpAddress?.ToString() ?? "Desconocido",
                    userAgent: context.Request.Headers["User-Agent"].FirstOrDefault() ?? "Desconocido",
                    machineName: Environment.MachineName,
                    os: Environment.OSVersion.ToString(),
                    host: context.Request.Host.ToString() ?? "Desconocido",
                    distribution: "Desconocido"
                ));
                logBuilder.AppendLine(LogFormatter.FormatEnvironmentInfoEnd());

                // Se registra el endpoint de la petición.
                string endpointName = context.Request.Path;
                logBuilder.AppendLine(LogFormatter.FormatEndpoint(endpointName));

                // Se captura y registra la información de la solicitud.
                logBuilder.AppendLine(LogFormatter.FormatRequestInfoStart());
                logBuilder.AppendLine(await CaptureRequestInfoAsync(context));
                logBuilder.AppendLine(LogFormatter.FormatRequestInfoEnd());

                // Se invoca el siguiente middleware o la acción del controlador.
                await _next(context);

                // Se captura y registra la información de la respuesta.
                logBuilder.AppendLine(LogFormatter.FormatResponseInfo(CaptureResponseInfo(context)));

                // Se vuelve a registrar el endpoint al finalizar.
                logBuilder.AppendLine(LogFormatter.FormatEndpoint(endpointName));

                // Se registra un bloque de excepciones (sin excepciones en este caso).
                logBuilder.AppendLine(LogFormatter.FormatExceptionDetails("Sin excepciones"));

                // Se agrega el bloque final de cierre del log.
                logBuilder.AppendLine(LogFormatter.FormatEndLog());

                // Se escribe todo el contenido en el archivo de log.
                File.AppendAllText(logFileName, logBuilder.ToString());
            }
            catch (Exception ex)
            {
                _loggingService.AddExceptionLog(ex);
            }
        }

        /// <summary>
        /// Obtiene la ruta del directorio de logs combinando la ruta base de la configuración con el nombre de la API.
        /// </summary>
        /// <returns>Ruta completa del directorio de logs.</returns>
        private string GetLogDirectory()
        {
            string apiName = !string.IsNullOrWhiteSpace(_hostEnvironment.ApplicationName)
                                ? _hostEnvironment.ApplicationName
                                : "Desconocido";
            string directory = Path.Combine(_baseLogDirectory, apiName);
            try
            {
                if (!Directory.Exists(directory))
                    Directory.CreateDirectory(directory);
            }
            catch (Exception ex)
            {
                _loggingService.AddExceptionLog(ex);
            }
            return directory;
        }

        /// <summary>
        /// Método estático que captura la información de la solicitud.
        /// </summary>
        /// <param name="context">Contexto HTTP de la solicitud.</param>
        /// <returns>Cadena con detalles de la solicitud.</returns>
        private static async Task<string> CaptureRequestInfoAsync(HttpContext context)
        {
            try
            {
                var request = context.Request;
                string headers = string.Join(Environment.NewLine, request.Headers.Select(h => $"{h.Key}: {h.Value}"));
                string query = request.QueryString.ToString();
                string ip = context.Connection.RemoteIpAddress?.ToString() ?? "Desconocido";
                string method = request.Method;
                string body = string.Empty;

                request.EnableBuffering();
                using (var reader = new StreamReader(request.Body, leaveOpen: true))
                {
                    body = await reader.ReadToEndAsync();
                    request.Body.Position = 0;
                }

                var sb = new StringBuilder();
                sb.AppendLine($"IP: {ip}");
                sb.AppendLine($"Method: {method}");
                sb.AppendLine($"Query: {query}");
                sb.AppendLine($"Headers: {headers}");
                sb.AppendLine("Body: ");
                sb.AppendLine(body);
                return sb.ToString();
            }
            catch
            {
                return "No se pudo capturar la información de la solicitud.";
            }
        }

        /// <summary>
        /// Método estático que captura la información de la respuesta.
        /// </summary>
        /// <param name="context">Contexto HTTP de la respuesta.</param>
        /// <returns>Cadena con detalles de la respuesta.</returns>
        private static string CaptureResponseInfo(HttpContext context)
        {
            try
            {
                var response = context.Response;
                string headers = string.Join(Environment.NewLine, response.Headers.Select(h => $"{h.Key}: {h.Value}"));
                return $"StatusCode: {response.StatusCode}{Environment.NewLine}Headers: {headers}";
            }
            catch
            {
                return "No se pudo capturar la información de la respuesta.";
            }
        }
    }
}
