private string GetCurrentLogFile()
{
    try
    {
        var context = _httpContextAccessor.HttpContext;
        if (context != null)
        {
            // Si el log ya estÃ¡ asignado a la peticiÃ³n, lo usamos
            if (context.Items.ContainsKey("LogFileName"))
            {
                return context.Items["LogFileName"] as string;
            }

            // ðŸ”¹ Generamos un nombre Ãºnico basado en el Execution ID, Endpoint y Hora
            string executionId = context.TraceIdentifier ?? Guid.NewGuid().ToString();
            string endpoint = context.Request.Path.Value?.Replace("/", "_") ?? "UnknownEndpoint";
            string timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
            string logFilePath = Path.Combine(_logDirectory, $"{executionId}_{endpoint}_{timestamp}.txt");

            // ðŸ”¹ Guardamos el archivo en el HttpContext para que sea reutilizado
            context.Items["LogFileName"] = logFilePath;

            Console.WriteLine($"[DEBUG] Archivo de log asignado: {logFilePath}"); // Para depuraciÃ³n

            return logFilePath;
        }
    }
    catch (Exception ex)
    {
        LogInternalError(ex);
    }

    // ðŸ”¹ Si no hay contexto, usar un log global
    return Path.Combine(_logDirectory, "GlobalManualLogs.txt");
}
