using Logging.Abstractions;
using Logging.Helpers;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Controllers;
using System.Diagnostics;
using System.Linq;
using System.Text.Json;

namespace Logging.Filters
{
    /// <summary>
    /// Filtro de acción que se ejecuta antes y después de la acción de un controlador.
    /// Se encarga de capturar y registrar los parámetros de entrada, la salida y el tiempo de ejecución.
    /// Utiliza scopes anidados para reflejar la jerarquía del flujo de ejecución.
    /// </summary>
    public class LoggingActionFilter : IActionFilter
    {
        private readonly ILoggingService _loggingService;
        private readonly string _controllerName;
        private readonly string _actionName;
        private Stopwatch _stopwatch;

        /// <summary>
        /// Constructor que inicializa el filtro con el servicio de logging y extrae la información del controlador y acción.
        /// </summary>
        /// <param name="loggingService">Servicio de logging inyectado.</param>
        /// <param name="actionDescriptor">Descriptor de la acción, del cual se extraen nombres.</param>
        public LoggingActionFilter(ILoggingService loggingService, ActionDescriptor actionDescriptor)
        {
            _loggingService = loggingService;
            _controllerName = actionDescriptor.RouteValues["controller"];
            _actionName = actionDescriptor.RouteValues["action"];
        }

        /// <summary>
        /// Se ejecuta antes de que se invoque la acción del controlador.
        /// Inicia el cronómetro, registra parámetros de entrada y un mensaje de inicio.
        /// </summary>
        /// <param name="context">Contexto de ejecución de la acción.</param>
        public void OnActionExecuting(ActionExecutingContext context)
        {
            try
            {
                // Uso de using declaration para crear un scope anidado
                using var scope = new LogScope();
                _stopwatch = Stopwatch.StartNew();

                // Serializa los parámetros de entrada y los registra
                var inputParams = string.Join(System.Environment.NewLine,
                    context.ActionArguments.Select(arg =>
                        $"{arg.Key} = {(arg.Value != null ? JsonSerializer.Serialize(arg.Value, new JsonSerializerOptions { WriteIndented = true }) : "Desconocido") }"));
                _loggingService.AddInputParameters(inputParams);

                // Registra un log indicando el inicio de la ejecución
                _loggingService.AddSingleLog($"Inicio de ejecución en Controller: {_controllerName}, Action: {_actionName}");
            }
            catch (System.Exception ex)
            {
                _loggingService.AddExceptionLog(ex);
            }
        }

        /// <summary>
        /// Se ejecuta después de la acción del controlador.
        /// Detiene el cronómetro, registra los parámetros de salida y un mensaje final con el tiempo de ejecución.
        /// </summary>
        /// <param name="context">Contexto de ejecución, que incluye el resultado de la acción.</param>
        public void OnActionExecuted(ActionExecutedContext context)
        {
            try
            {
                using var scope = new LogScope();
                _stopwatch.Stop();

                // Captura y serializa el resultado de la acción, si es posible
                string outputParams = "Sin datos de salida";
                if (context.Result is ObjectResult objectResult && objectResult.Value != null)
                {
                    outputParams = JsonSerializer.Serialize(objectResult.Value, new JsonSerializerOptions { WriteIndented = true });
                }
                _loggingService.AddOutputParameters(outputParams);

                // Registra un log indicando el fin de la ejecución y el tiempo transcurrido
                _loggingService.AddSingleLog($"Fin de ejecución en Controller: {_controllerName}, Action: {_actionName} en {_stopwatch.ElapsedMilliseconds} ms");
            }
            catch (System.Exception ex)
            {
                _loggingService.AddExceptionLog(ex);
            }
        }
    }
}
